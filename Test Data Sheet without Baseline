###### Automation Code for Test Data Sheet without Baseline  ######


import os
import pandas as pd
from docx import Document
from docx.shared import RGBColor
from docx.table import Table
from docx.text.paragraph import Paragraph
from PyPDF2 import PdfReader
import re

def extract_table_after_heading(docx_path, heading_text):
    """

    Extracts a table from a Word document that appears immediately after a given heading.

    Returns a pandas DataFrame.

    """

    doc = Document(docx_path)

    all_elements = list(doc.element.body.iterchildren())

    found_heading = False

    for element in all_elements:

        if element.tag.endswith('p'):

            para = Paragraph(element, doc)

            para_text = para.text.strip()

            style = para.style.name if para.style else ""

            if para_text == heading_text.strip() and style.startswith("Heading"):
                found_heading = True

                continue

        if found_heading and element.tag.endswith('tbl'):

            table = Table(element, doc)

            rows_data = []

            for row in table.rows:
                row_data = [cell.text.strip() for cell in row.cells]

                rows_data.append(row_data)

            if not rows_data:
                return pd.DataFrame()

            header = rows_data[0]

            num_cols = len(header)

            clean_rows = []

            for row in rows_data[1:]:

                if len(row) < num_cols:

                    row += [""] * (num_cols - len(row))

                elif len(row) > num_cols:

                    row = row[:num_cols]

                clean_rows.append(row)

            df = pd.DataFrame(clean_rows, columns=header)

            df.rename(columns={'Test Procedure Name Or Activity': 'Test Procedure Name',
                               'DOORS View or Test Activity': 'Test Procedure View',
                               'Test Folder': 'Test Folder Number',
                               'Test Procedure Section(s)': 'Section(s) Performed'}, inplace=True)

            return df

    return None


def fill_word_template(df, template_path, output_dir, special_field,):
    """

    Fill a Word template with values from a DataFrame.

    Saves one document per row in output_dir.

    """

    os.makedirs(output_dir, exist_ok=True)

    for idx, row in df.iterrows():

        doc = Document(template_path)

        for table in doc.tables:

            num_rows = len(table.rows)

            num_cols = len(table.rows[0].cells) if num_rows > 0 else 0

            for r in range(num_rows):

                for c in range(num_cols):

                    cell = table.cell(r, c)

                    for key in df.columns:

                        if key in cell.text:

                            if key == special_field:

                                if r + 1 < num_rows:
                                    target_cell = table.cell(r + 1, c)

                                    target_cell.text = ""

                                    run = target_cell.paragraphs[0].add_run(str(row[key]))

                                    run.font.color.rgb = RGBColor(0, 0, 255)

                            else:

                                for para in cell.paragraphs:

                                    if key in para.text:

                                        parts = para.text.split(":", 1)

                                        if len(parts) > 1:

                                            new_value = str(row[key])

                                            before_colon = True

                                            for run in para.runs:

                                                if before_colon:

                                                    if ":" in run.text:
                                                        colon_index = run.text.index(":") + 1

                                                        run.text = run.text[:colon_index]

                                                        new_run = para.add_run(f" {new_value}")

                                                        new_run.font.color.rgb = RGBColor(0, 0, 255)

                                                        before_colon = False

                                                else:

                                                    run.text = ""

        first_val = str(row.iloc[0]).replace("/", "-").replace("\\", "-")
        second_val = str(row.iloc[1]).replace("/", "-").replace("\\", "-")

        third_val = str(row.iloc[2]).replace("/", "-").replace("\\", "-")

        filename = f"{first_val}_{second_val}_{third_val}.docx"

        filepath = os.path.join(output_dir, filename)

        doc.save(filepath)

    print(f"Documents saved in: {output_dir}")


# ===== Workflow =====

# Step 1: Extract DataFrame from Word

df = extract_table_after_heading(

    docx_path="C:\\Users\\320160242\\Documents\\VM14.0\\TestDataSheetAutomation\\13.0Plan.docx",
    # Source Word file containing the table

    heading_text="Addenda"

)

# df.drop(['Index','Estimated Effort Hours','Hardware Configuration'],axis=1,inplace=True)

# Step 2: Fill Word templates for each row

if df is not None and not df.empty:

    fill_word_template(

        df=df,

        template_path="C:\\Users\\320160242\\Documents\\VM14.0\\TestDataSheetAutomation\\TestDataSheet.docx",  # Your template

        output_dir="C:\\Users\\320160242\\Documents\\VM14.0\\TestDataSheetAutomation\\output",  # Directory to store files

        special_field="Section(s) Performed"

    )

else:

    print("No data found after the given heading.")

